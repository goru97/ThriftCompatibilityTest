var util = require('util'),
    EventEmitter = require("events").EventEmitter,
    net = require('net'),
    TMemoryBuffer = require('./transport').TMemoryBuffer,
    TBinaryProtocol = require('./protocol').TBinaryProtocol,
    zlib = require('zlib');

var binary = require('./binary');

var int32FramedReceiver = exports.int32FramedReceiver = function (callback) {
  var frameLeft = 0,
      framePos = 0,
      frame = null;
  var residual = null;

  return function(data) {
    // Prepend any residual data from our previous read
    if (residual) {
      var dat = new Buffer(data.length + residual.length);
      residual.copy(dat, 0, 0);
      data.copy(dat, residual.length, 0);
      residual = null;
      data = dat;
    }

    // var buf = new Buffer(data, 'binary');
    // console.log(buf);
    // framed transport
    while (data.length) {
      if (frameLeft === 0) {
        // TODO assumes we have all 4 bytes
        if (data.length < 4) {
          residual = data;
          break;
        }
        frameLeft = binary.readI32(data);
        frame = new Buffer(frameLeft);
        framePos = 0;
        data = data.slice(4, data.length);
      }

      if (data.length >= frameLeft) {
        data.copy(frame, framePos, 0, frameLeft);
        data = data.slice(frameLeft, data.length);

        frameLeft = 0;
        callback(frame);
      } else if (data.length) {
        data.copy(frame, framePos, 0, data.length);
        frameLeft -= data.length;
        framePos += data.length;
        data = data.slice(data.length, data.length);
      }
    }
  };
};

var Connection = exports.Connection = function(stream, options) {
  var self = this;
  EventEmitter.call(this);

  this.connection = stream;
  this.offline_queue = [];
  this.options = options || {};
  this.connected = false;

  if (options && options.hasOwnProperty('useCompression')) {
    this.useCompression = (options.useCompression === true);

    //compression engine
    this.compressor = {};
    this.compressor.engine = zlib.createDeflate();
    this.compressor.output = [];
    this.compressor.outputLen = 0;
    this.compressor.engine.on('data', function(chunk) {
      self.compressor.output.push(chunk);
      self.compressor.outputLen += chunk.length;
    });
    this.compressor.engine.on('error', function(err) {
      this.compressor.engine.reset();
      self.emit('error', err);
    });

    //decompression engine
    this.decompressor = {};
    this.decompressor.engine = zlib.createInflate();
    this.decompressor.output = [];
    this.decompressor.outputLen = 0;
    this.decompressor.engine.on('data', function(chunk) {
      self.decompressor.output.push(chunk);
      self.decompressor.outputLen += chunk.length;
    });
    this.decompressor.engine.on('error', function(err) {
      this.decompressor.engine.reset();
      self.emit('error', err);
    });
  } else {
    this.useCompression = false;
  }


  this.connection.addListener("connect", function() {
    self.connected = true;
    this.setTimeout(self.options.timeout || 0);
    this.setNoDelay();
    this.frameLeft = 0;
    this.framePos = 0;
    this.frame = null;

    self.offline_queue.forEach(function(data) {
      self.connection.write(data);
    });

    self.emit("connect");
  });

  this.connection.addListener("error", function(err) {
    // Only emit the error if no-one else is listening on the connection
    // or if someone is listening on us
    if (self.connection.listeners('error').length === 1
        || self.listeners('error').length > 0) {
      self.emit("error", err)
    }
  });

  // Add a close listener
  this.connection.addListener("close", function() {
    self.emit("close");
  });

  this.connection.addListener("timeout", function() {
    self.emit("timeout");
  });

  this.connection.addListener('data', int32FramedReceiver(function(data) {
    if (self.useCompression) {
      self.decompressor.engine.write(data);
      self.decompressor.engine.flush(function() {
        var buffer = new Buffer(self.decompressor.outputLen),
            currentPos = 0, i;

        for (i in self.decompressor.output) {
          var chunk = self.decompressor.output[i];
          chunk.copy(buffer, currentPos, 0, chunk.length);
          currentPos += chunk.length;
        }
        self.decompressor.output = [];
        self.decompressor.outputLen = 0;

        processRxFrame(buffer);
      });
    } else {
      processRxFrame(data);
    }

    function processRxFrame(frame) {
      var input = new TBinaryProtocol(new TMemoryBuffer(frame));
      var r = input.readMessageBegin();
      self.client['recv_' + r.fname](input, r.mtype, r.rseqid);
    }
  }));
};

util.inherits(Connection, EventEmitter);

exports.createConnection = function(host, port, options) {
  var stream = net.createConnection(port, host);
  var connection = new Connection(stream, options);
  connection.host = host;
  connection.port = port;

  return connection;
}

exports.createClient = function(cls, connection) {
  if (cls.Client) {
    cls = cls.Client;
  }
  var client = new cls(new TMemoryBuffer(undefined, function(buf) {
      if(connection.useCompression) {
        connection.compressor.engine.write(buf);
        connection.compressor.engine.flush(function() {
          var buffer = new Buffer(connection.compressor.outputLen),
              currentPos = 0;

          for (var i in connection.compressor.output) {
            var chunk = connection.compressor.output[i];
            chunk.copy(buffer, currentPos, 0, chunk.length);
            currentPos += chunk.length;
          }
          connection.compressor.output = [];
          connection.compressor.outputLen = 0;
          connection.write(buffer);
        });
      } else {
        connection.write(buf);
      }
  }), TBinaryProtocol);

  // TODO clean this up
  connection.client = client;

  return client;
}

Connection.prototype.end = function() {
  this.connection.end();
}

Connection.prototype.write = function(buf) {
  // TODO: optimize this better, allocate one buffer instead of both:
  var msg = new Buffer(buf.length + 4);
  binary.writeI32(msg, buf.length);

  buf.copy(msg, 4, 0, buf.length);
  if (!this.connected) {
    this.offline_queue.push(msg);
  } else {
    this.connection.write(msg);
  }
}
